需求说明：
经常会处理大量数据时 笔记本内存不足 影响处理速度 尤其是单一处理程序需要大量内存情况下
解决方案：
使用内存映射文件扩充内存
实现方法：
  简单起见 一开始就规划内存最大的尺寸 通常比预估尺寸要大一些 这样文件头信息就可以一开始就固定下来
  以32个字节为最小申请单位, 以1位表示该内存的使用情况 在物理内存建立空闲内存的映射表 根据申请的内存大小就可以快速获取内存地址
  以 1M 为例 
  头信息 大小 4096 = 1M/32/8
  第一位表示对应地址 4096 尺寸32字节的内存地址
  第10位表示对应地址 4096+10*32 尺寸32字节的内存地址
  如果是256G 头信息就有1G 32G 头信息 128M

那么如何管理这些信息
  需要建立两个按尺寸排序的链表 结构 start stop size next prev 一个可用 usbale 一个不可用 occupy
  开始时可用仅仅有1条记录 0 4095 1M 0 0
  第1个内存申请64字节
  usbale  (2 4096 1M-64)
  occupy  (0    1 64)
  第2个内存申请128字节
  usbale  (6 4096 1M-64)
  occupy  (0    1 64)(2    5 128)
  释放第一个内存
  usbale  (0    1 64)(6 4096 1M-64)
  occupy  (2    5 128)
  此时申请1个128字节的内存
  usbale  (0    1 64)(10 4096 1M-64)
  occupy  (2    5 128)(6    9 128)
==== 从这里可以看出 size 是不需要的 size = (stop - start + 1) * 32
  以此类推 realloc 也可以先看其后是否有空闲
  且memset memmove 也不会影响其功能

==== 到这里似乎很简单完美 但是问题来了 多个进程同时访问该内存要怎么玩 高级玩法需要同步信号量 但新的问题又来了 需要对每个内存建立一个读写锁
==== 问题的简单解决方法 估算本进程的内存使用量 每个进程自己管理自己的map文件 问题得到简单的解决 至于读写锁的问题和物理内存一样 由程序自己解决

==== 实际编程中发现 头信息没有用处 难道还指望程序退出后 可以重用上次的内存吗 如果只是单进程存储的信息也只有本次运行有效 

==== 其实占用链表也不需要 只需要在使用的内存保存node的地址 就可以快速检索 和 free 记得 free时设置 head == -1 这样可以避免二次free
目前只有 usable 链表维护耗时 