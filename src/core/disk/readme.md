
文件结构说明：

        sis_disk_files 只处理单一文件的读取写入功能 不提供压缩解压
    sis_disk.io.log 提供log文件的读写功能
    sis_disk.io.sno 提供sno文件的读写功能
    sis_disk.io.sdb 提供sdb文件的读写功能
        sis_disk_dict 处理sno和sdb的字典操作函数 
    sis_disk.io.h   提供给内部程序交互访问的接口和类型
sis_disk.c   提供给外部用户访问的函数定义
sis_disk.h   提供给外部用户访问的接口和类型


////////////////////////////////////////////////////
// 内部标准定义
////////////////////////////////////////////////////
// 一共5种数据文件格式 和 2种索引文件格式 
// 1. 实时日志文件 无时序 无索引 无文件尾 此类文件只能追加数据
//    一般作为记录写入动作的实时记录 按写入顺序落盘 以天为一个文件
//    确认物理写盘后才返回写入成功 重新加载时从头顺序读 直到最后一个合法的数据块
//    通常会在一天结束后 转换为磁盘其他数据格式 并清理删除
#define  SIS_DISK_TYPE_LOG         1 // name.20210121.log
// 2. 顺序SNO日记文件 此类文件只能追加结构化数据 按时序压缩写入 无索引 有文件尾 此类文件只能追加数据
//    存在的价值主要用于历史全盘数据回放 以避免解压压缩过程提高读取速度 以天为一个文件
//    文件可以直接提取磁盘数据进行网络传输  支持压缩期间增加key和sdb
//    文件以16K一个数据块 以1024个数据块为一个数据包 以SIS_DISK_HID_SNO_END 分隔
//    数据从头开始的加载 直到读取到文件尾 由于可能定位读取数据 文件分块存储
#define  SIS_DISK_TYPE_SNO         2  // name/sno/2021/20210121.sno
////////////////////////////////////////////////////
//    同一文件组中 一个key+sdb只有一个数据块，如果有修改后写的会替代新的 不pack新旧数据都在 区别是内存索引会变
//    若单个文件过大 就会生成新的文件.1.2.3 但索引不变，
//    索引文件对每个key需要保存一个 active 字节 0..255 每次写盘时如果没有增加就减 1 以此来判断key的热度  
//    文件一律分块存储
////////////////////////////////////////////////////
// 3. 标准SDB数据文件 无时序 有索引 有文件尾 name.sdb 会有[所有]的key [最新]的结构体名和结构sdb
//    但name的索引只有无时序的数据索引 加载时仅仅加载key和sdb 以方便确定数据是否可能存在
//    根据查询时间再打开对应目录时序文件 才能得到真实的数据节点
#define  SIS_DISK_TYPE_SDB_NOTS    3   // name/nots/name.sdb name.idx
// 4. 大尺度SDB数据文件 有时序 有索引 有文件尾 时间字段为日和以上级别的按每10年为一个区间存储数据
// 按5000key算 一条100 一年250天 = 1.25G 原始数据 支持增量写入 时间有重叠需要合并后写入 PACK时合并数据
#define  SIS_DISK_TYPE_SDB_YEAR    4   // name/year/2010-2019.sdb
// 5. 小尺度SDB数据文件 有时序 有索引 有文件尾 时间字段为日以下的按每天为一个区间存储数据
// 按5000key算 一条100 一天5000条 = 2.5G 原始数据 通常KEY对应一块数据 PACK时清理过期数据块 保留最后一块数据
#define  SIS_DISK_TYPE_SDB_DATE    6   // name/date/2021/20210606.sdb
// 没有对分钟线专门处理 是因为正常分析时通常以天总览 以天为细节分析
////////////////////////////////////////////////////
// 1. sno的索引文件 记录key和sdb的信息 以及每个段的 以SIS_DISK_HID_SNO_END 信息 方便按时间点获取数据 时间为毫秒
//    索引文件由于必须全部加载 不分块存储
#define  SIS_DISK_TYPE_SNO_IDX    10 
// 2. ssb的索引文件 记录key和sdb的信息 以及每个key+sdb的位置信息 时间统一为毫秒
//    索引文件由于必须全部加载 不分块存储
#define  SIS_DISK_TYPE_SDB_IDX    11
////////////////////////////////////////////////////
// PACK时需要合并所有key 主文件只保留最新的 SDB 
// 由于非时序的结构体后面覆盖前面的值 因此不用保留老的结构定义
// 时序化结构体会保留在各自的文件中 PACK时会统一当前文件的数据结构到最新结构体 
// 所以主文件只有非结构化数据和索引
////////////////////////////////////////////////////

////////////////////////////////////////////////////
// 文件所有数据块都有 SIS_DISK_BLOCK_HEAD 头来描述后面的数据的特性
#define SIS_DISK_BLOCK_HEAD  \
		uint8 fin : 1;    \
		uint8 zip : 2;    \
		uint8 hid : 5;    \
// zip 压缩方法 0 - 不压缩 1 - snappy 2 - 结构增量压缩 3 其他
// 后面紧跟 size(dsize) 为数据区长度 根据实际数据长度可以得到数据有多少条
////////////////////////////////////////////////////
// hid 的定义如下 最多有32种头描述
////////////////////////////////////////////////////
#define  SIS_DISK_HID_NONE        0x0  // 表示该块为删除标记
// 文件头
#define  SIS_DISK_HID_HEAD        0x1  // 表示为文件头描述
// 键值的定义
#define  SIS_DISK_HID_DICT_KEY    0x2  // key的描述 k1,k2... 以,隔开,可多个key 根据顺序得到索引
// 结构属性定义
#define  SIS_DISK_HID_DICT_SDB    0x3  // sdb的结构描述 x:{},y:{},z:{} 可以多个sdb 根据顺序得到索引
// LOG的自由数据块                    
#define  SIS_DISK_HID_MSG_LOG     0x4  // size(dsize)+datastream 自行决定数据区数据格式
// SNO的数据块 默认多key多sdb压缩数据   
#define  SIS_DISK_HID_MSG_SNO     0x5  // size(dsize)+incrzipstream 
// SNO数据块结束符 收到此消息后 表明数据压缩重新开始
#define  SIS_DISK_HID_SNO_END     0x6  // 跟8位毫秒的时间戳
// 无时序的结构数据 单key单sdb的 通用压缩数据
// 需要有 SIS_DISK_HID_DICT_KEY 和 SIS_DISK_HID_DICT_SDB
#define  SIS_DISK_HID_MSG_NON     0x7  // size(dsize)+kid(dsize)+dbid(dsize)+[datastream] 一个key+N条记录
// SDB的通用数据块 单key单sdb的增量压缩数据
// 需要有 SIS_DISK_HID_DICT_KEY 和 SIS_DISK_HID_DICT_SDB
#define  SIS_DISK_HID_MSG_SDB     0x8  // size(dsize)+kid(dsize)+dbid(dsize)+[incrzipstream] 一个key+N条记录
// SDB的无时序的非结构数据 单key无sdb 单条记录 通用压缩数据
#define  SIS_DISK_HID_MSG_ONE     0x9  // size(dsize)+klen(dsize)+kname+style(dsize)+vlen(dsize)+datastream
// SDB的无时序的非结构数据 单key无sdb 多条记录 通用压缩数据
#define  SIS_DISK_HID_MSG_MUL     0xA  // size(dsize)+klen(dsize)+kname+style(dsize)+count(dsize)+[vlen(dsize)+datastream...]

/////////////////////////////////////////////////////////
// 读取索引文件必须加载全部数据 *** 特别重要 *** 数据文件才有意义
////////////////////////////////////////////////////
// 格式为 klen(dsize)+kname+dblen(dsize)+dname+blocks(dsize)
//         +[active(1)+kdict(dsize)+sdict(dsize)+fidx(dsize)+offset(dsize)+size(dsize)+start(dsize)+stop(dsize)]...
// stop通常存储时为start的偏移量
#define  SIS_DISK_HID_INDEX_MSG   0x10 
// 一个文件可能会出现多次字典信息写入 每次写入都会先写字典表，读取时也是先读字典 后续索引才能一一匹配
// 格式为 blocks(dsize)+[fidx(dsize)+offset(dsize)+size(dsize)]...
#define  SIS_DISK_HID_INDEX_KEY   0x11
// 格式为 blocks(dsize)+[fidx(dsize)+offset(dsize)+size(dsize)]...
#define  SIS_DISK_HID_INDEX_SDB   0x12
// SNO的块结束索引 存储当前最后时间毫秒
// 格式为 fidx(dsize)+offset(dsize)+size(dsize)+stop(dsize)
#define  SIS_DISK_HID_INDEX_SNO   0x13 

// O为中间代理层 S为源头 C为接收
// #define  SIS_NET_HID_OWNE         0x18  // SO 或 CO 的私有交互
// #define  SIS_NET_HID_SUB          0x19  // C-->O 向O订阅需要的数据 以便O按需分配
// #define  SIS_NET_HID_PUB          0x1A  // S-->O O缓存定量数据 数据随到随分发给 C 
// #define  SIS_NET_HID_GET          0x1B  // C-->O 只能获取S端set的数据
// #define  SIS_NET_HID_SET          0x1C  // S-->O O保存和更新该数据，等待C的get

// 文件结束块
#define  SIS_DISK_HID_TAIL        0x1F  // 结束块标记
/////////////////////////////////////////////////////////



// 内存加载时仅仅加载最近活跃的数据 
// dict 针对key和sdb的字典表不同 dict 表示不同的字典表 读取时对应dict的字典表为当前的数据

// 字典表应该是这样的
// 第一次写入的为全字典 后续写的如果内容一样 不增加 如果新的数据字典为新的就直接写入
// 注意 新写入的数据总是以当前key值最大的索引为参考 
// 如果内容不同 在同名下增加 一个属性内容 并做好索引 然后把新增的信息字典 写盘 不用写全部字典
// 对已经存在的文件 打开文件时需要加载全部的字典表 
// 读取数据时如果根据 dict 不同加载不同信息 但 name 一致  
// 这样即使前后结构不同 通过格式转换 老的数据结构也可以解析成新的结构返回给前端
// 通过pack可以把旧结构数据转成新的数据结构 字典表也就只有一个完整的了 


//////////// 以下是索引文件定义 ////////////////
// 文件记录格式为 klen(dsize)+key+slen(dsize)+sdb+blocks(dsize)
//         +[active(1)+kdict(dsize)+sdict(dsize)+fidx(dsize)+offset(dsize)+size(dsize)+start(dsize)+stop(dsize)]...
// 直接用字符串不用id是为了适应其他没有字典的文件格式
// kdict 为 当前key对应的字典单元 sdict 当前sdb对应的字典单元
// fidx 为 文件序号 数据过大，会分块存储 此为编号
// start 为开始时间 可以为秒 年 毫秒 但同一组数据该值最好保持一致
// stop 为 start 的时间偏移
// 索引文件为一次性写入 文件名以默认规则来命名 避免索引文件过大
// 用户检索时只需要打开对应时段的索引即可
// 增加一个字节标记 active 1..255 表示活跃度 整理历史数据和加载内存时可参考 
// 刚写入时 = 1 第二次写索引时 如果没有操作就 = 0 
// 255 表示经常读写 
// 最近一次写索引 如果该键值没有被读写就减 1
// 仅在有修改情况和PACK情况时会重写IDX 其他任何时候只是添加索引块记录
// 读取需要一次性加载所有索引信息
// ---------- //

////////////////////////////////////////////////////
// 这是一个高效写入的模块，需要满足以下特性
// LOG文件写入数据要同步 必须保证写入磁盘后才返回 保证数据的完整性 没有文件尾 没有索引
//       读取时必须从头读 读到尾部需要检查文件长度 如果长度不符合就舍弃最后的信息 从完整的信息末尾继续写入数据
//       LOG数据传入什么写什么 按天存储 日期切换就打开新的文件 是所有其他数据的来源和凭证
// 
// SNO 文件按时间序列压缩 为便于直接网络传输 16K为一个块 1024个块后重新压缩 一天大概240个块的数据
//     只能顺序读取全部数据 不能修改 文件名就包含日期 now/sno/2021/20210121.sno
//     没有索引 没有文件尾 通用头+key+sdb+数据块
//     对sisdb来说 sno 可以应用到任何组中 
//     收到 start 后开始启动 sno 记录服务
//     然后等待 setkey setsdb zpub信息 如果是ipub spub 未压缩数据 需要在stop时转为压缩格式
//     收到 stop 指令后就会把收到的修改数据转为sno格式
//     sno文件主要应用在全部数据订阅时使用 可以快速返回数据 辅助作用 
//     sno支持压缩期间增加key和sdb
//     多key多sdb订阅 都是通过sdb结构数据来获取
//     
// -------------------------------------------- //
// 对sisdb来说 所有的数据都是结构化数据
// 除了标准的结构化定义 系统默认存在 以下四种数据结构 
// string:{index:I, value:S}  不定长数据流  --- 无时序
// factor:{time :T,  value:double} 原子数据 毫秒 浮点数 主要存储单列因子 --- 有时序
// 通过特定命令 读写默认结构 
// 例子1：fset 00001.macd {time: 100, value: 12.60} # 可以只带 value
//       fset 00001.macd 12.60     # 必须是浮点数 默认增加一条记录
//   系统会自动生成 macd 数据表 表格式用atom
//   并自动生成时间信息 和数据一起存放到数据表中
//   读取时和其他数据表没有区别
//   系统自动在 00001.macd 键值获取实际数据
//   如果是二进制写入模式 必须完整写入 64位整数+64位浮点数 
// 例子2：sset 00001.info xxxxxxx   # 任意字符串 默认修改最后一条信息
//       sadd 00001.info xxxxxxx   # 增加一条信息
//   系统自动生成 info 数据表 {index:I, value:S} 如果结构体不一样返回错误 
// *** 只有无时序的数据结构才支持有add指令 有时序的数据结构通常用set *** 
// -------------------------------------------- //
// SDB 以不同表分别存储 
//     mdb/mdb.sdb 无时序的数据放一起 
//         mdb.idx 这里定义一个所有key和所有sdb的json文件（这里保存的一定是最全的、最新的结构定义）
//        有以下几个默认结构体:
//        单字符串      ochars: {fields: { index: [I,4,1,0,O] value: [S]}} 
//        字符串列表    chars:  {fields: { index: [I,4,1,0,O] value: [S]}} 
//        单json串     ojsons: {fields: { index: [I,4,1,0,O] value: [J]}} 
//        json串列表   jsons:  {fields: { index: [I,4,1,0,O] value: [J]}} 
//        单二进制流    obytes: {fields: { index: [I,4,1,0,O] value: [B]}} // 传入时根据表名 index 自增或固定为0 可以表示两种结构
//        二进制流列表  bytes: {fields: { index: [I,4,1,0,O] value: [B]}} 
//        特征因子表   factor: {fields: { time: [T,8,1,0,OI] value: [F,8,1,5]}} // 传入时根据表名 index 自增或固定为0 可以表示两种结构

//        可以是单独key（结构体为可变长字节流 一条记录）B(byte) J(json) S(string) 三种数据结构
//        可以是列表   （结构体为可变长字节流 多条记录） 
//        按键取值 每个键仅有一个索引和有效数据块
//        数据订阅时 无时序数据会最先发布
//     有时序的数据 日期以上按10年一个文件 每个数据块就是10年数据 mdb/20000101-20091231.sdb 文件大小为4G
//                其他时序按1天一个文件  每个数据块就是key+sdb一天的数据 mdb/2021/20210606.sdb 文件大小为4G 
//                每个文件有各自的索引文件
//     即便后期增加数据也只会写入对应日期的文件中 方便数据迁移和备份 并能快速定位数据时间
//     可修改 修改后的数据只做覆盖追加处理  pack时清理冗余数据 如果文件被删除 索引在pack后也会清理不存在的数据
// 文件不在了 即使索引在 也会返回空
// 如果索引文件破坏，就重新建立索引，要求能够通过数据文件完整生成索引文件 需时较长，需遍历所有的磁盘文件；
// 重建索引规则，同一个key，一旦后面的key时间和前面的数据时间有交叉（不包括粘连），前面的块就直接放弃
// 固定时间的保存方式 数据不会交叉
// 
// 所有定时存盘一般都是日期切换时进行 并且都只从LOG或STREAM中读取数据 和磁盘原始数据进行比对和写入 不和内存中数据打交互 
// 所以存盘开始时需要备份LOG文件 数据完全写好后 锁定读盘锁 然后移动原始磁盘文件到安全目录 再移动新文件到实际位置
// 保证即便其中任何环节出故障都可以恢复 原则上每天日期切换时做存盘操作 也可以通过配置指定存盘时间（但存盘后如果有数据写入切换日期后会再次写数据）
// 当天数据会根据内存大小 剔除读者少的KEY 按KEY读取排序 
// 启动时不加载数据 有读者才加载内存 写入的数据也会暂时放在内存 等待内存超限会清除

// 设置一个根目录后 子目录和后缀名自行配置 获取指定时间段的key+sdb直接到对应文件拿数据
// ***特别重要*** 若客户未指定日期 通常指最近一个块的数据
// sisdb管理数据时 需要把目录下所有目录和文件
// 仅仅对于SDB文件 在根目录下有一个隐藏文件 MDB.DEF 存储所有KEY和SDB的定义 只保留最新的数据
// 打开 各个分时文件用自己的索引 仅保留自己需要的KEY+SDB IDX首先加载到内存中 

// 根据数据时间 确定文件名 时序数据再次确定 日期包括以上 按10年为单位存储 日期以下按天为单位存储 大于4G后缀加1
// 这下所有主要数据表都统一到sisdb中来 sno仅仅作为一种LOG文件保留 
// 所有的key对应的都是结构化数据 即便是游历的数据都是结构化数据
////////////////////////////////////////////////////


// 把disk类的读取和写入提升一个纬度 以管理SBD多时序读写的问题
// 所有从disk读取的数据返回 head+size+原始块 有读者来决定如何拼接返回给上层调用者
// 所有写入到disk的数据也需要先在 IO 整合成 head+size+目标块 后发送到写入层
