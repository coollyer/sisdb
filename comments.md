##  什么是插件式编程
* 插件式编程是一种编程模式，该模式在函数式编程的基础上定制实现了一些较为高级的语言特性,如面向对象，反射机制等等
* 用面向对象的思维来理解，每个工作者（worker）相当于一个类的实例，类的成员方法在插件（module）中定义，类的成员变量在上下文（context）中存储
#### 对象特性如何实现
    与其他面向对象的高级语言相比，插件式编程中只有插件具有类的某些特性，相当于对OOP做了一定的裁剪

* 用面向对象的思维来理解，插件和工作者之间的关系相当于类和对象的关系,插件相当于一个类，每个工作者（worker）相当于一个类的实例，类的成员方法在插件（module）中定义，类的成员变量在上下文（context）中存储，因此在新定义一个插件的时候，需要同时新定义一个module用来实现插件的函数方法部分，新定义一个上下文结构体用来实现成员变量存储。
* 如果把工作者看作是插件实例的话，那么sis_worker_create就是所有工作者实例统一的构造函数，该函数实现了与C#类似的反射机制，通过JSON配置动态构造工作者实例
* 在OOP语言中，对象的成员变量用来存储独立的业务数据，在插件式编程中，上下文(s_sis_worker->context)具有类似的功能，某种程度上讲，它相当于c++的对象指针，用它可以访问所有的成员变量
* 插件的类型信息在程序中通过结构体s_sis_modules表示，该结构体包含一个s_sis_method数组，用以表示可对外提供的一组功能.
* 每一条s_sis_method记录表示一个功能，s_sis_method结构体包含了功能的名称、执行函数、权限和服务描述。
#### 插件的注册流程与反射机制
        反射是指程序在运行时动态获取对象属性与方法的一种机制，基于这种机制，程序可以根据JSON文件中的字符串动态构建类的实例，使程序具有极高的灵活性和可配置性，Java和C#本身具备反射的能力，c/c++一般来说不具备语言级别的反射机制
* 通过MakefileList，cmake程序在编译前自动生成modules.c文件，该文件根据插件目录（工作目录下drives以及以drives开头文件夹、sisdb下的works文件夹）下的源代码，声明了对所有能找到插件的s_sis_modules结构体列表，这些结构体的内容在各自的插件文件中定义，同时成modules.c文件声明了插件的名称列表，同一个插件其s_sis_modules结构体和名称在各自数组中的下标一致。
* 程序运行以后，main函数调用sis_server_init将所有的s_sis_modules和其对应名称装入到一个HASH表，这样在程序的其他地方可以通过插件名称迅速反查到对应的s_sis_modules并使用该插件对外提供的服务(s_sis_method)
* 用户通过在JSON文件中给工作者指定classname的方式告知工作者使用的插件名称，工作者在构造函数sis_worker_create中根据名称反查HASH表，获得对应插件类的服务函数定义。
#### 基于约定的接口机制

## 插件函数调用约定
插件函数可以看作是插件类的成员函数，其声明方式与matlab类似，即将this指针作为函数的第一个参数传入
c++
包含两个传入参数，第一个参数是工作者的指针，指向一个插件的实例，相当于c++里面的this指针，实际上matlab语言的类的成员函数也是采用类似的声明方法，将this指针作为成员函数参数列表的第一个参数传入。

## 各类型插件的接口
### 信号源(sisdb_rsno)
#### sub（订阅）
#### unsub（取消订阅）
#### setcb（设置回调函数）


## 疑问
几乎所有的service插件都会包含一个sub和unsub的功能，但是对应函数实际上什么也没做，请问下这两个功能对于service插件是必须的么？